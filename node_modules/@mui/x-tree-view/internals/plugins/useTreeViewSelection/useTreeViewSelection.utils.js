"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.propagateSelection = exports.getLookupFromArray = exports.getAddedAndRemovedItems = void 0;
var _useTreeViewSelection = require("./useTreeViewSelection.selectors");
var _useTreeViewItems = require("../useTreeViewItems/useTreeViewItems.selectors");
const getLookupFromArray = array => {
  const lookup = {};
  array.forEach(itemId => {
    lookup[itemId] = true;
  });
  return lookup;
};
exports.getLookupFromArray = getLookupFromArray;
const getAddedAndRemovedItems = ({
  store,
  oldModel,
  newModel
}) => {
  const newModelMap = new Map();
  newModel.forEach(id => {
    newModelMap.set(id, true);
  });
  return {
    added: newModel.filter(itemId => !_useTreeViewSelection.selectionSelectors.isItemSelected(store.state, itemId)),
    removed: oldModel.filter(itemId => !newModelMap.has(itemId))
  };
};
exports.getAddedAndRemovedItems = getAddedAndRemovedItems;
const propagateSelection = ({
  store,
  selectionPropagation,
  newModel,
  oldModel,
  additionalItemsToPropagate
}) => {
  if (!selectionPropagation.descendants && !selectionPropagation.parents) {
    return newModel;
  }
  let shouldRegenerateModel = false;
  const newModelLookup = getLookupFromArray(newModel);
  const changes = getAddedAndRemovedItems({
    store,
    newModel,
    oldModel
  });
  additionalItemsToPropagate?.forEach(itemId => {
    if (newModelLookup[itemId]) {
      if (!changes.added.includes(itemId)) {
        changes.added.push(itemId);
      }
    } else if (!changes.removed.includes(itemId)) {
      changes.removed.push(itemId);
    }
  });
  changes.added.forEach(addedItemId => {
    if (selectionPropagation.descendants) {
      const selectDescendants = itemId => {
        if (itemId !== addedItemId) {
          shouldRegenerateModel = true;
          newModelLookup[itemId] = true;
        }
        _useTreeViewItems.itemsSelectors.itemOrderedChildrenIds(store.state, itemId).forEach(selectDescendants);
      };
      selectDescendants(addedItemId);
    }
    if (selectionPropagation.parents) {
      const checkAllDescendantsSelected = itemId => {
        if (!newModelLookup[itemId]) {
          return false;
        }
        const children = _useTreeViewItems.itemsSelectors.itemOrderedChildrenIds(store.state, itemId);
        return children.every(checkAllDescendantsSelected);
      };
      const selectParents = itemId => {
        const parentId = _useTreeViewItems.itemsSelectors.itemParentId(store.state, itemId);
        if (parentId == null) {
          return;
        }
        const siblings = _useTreeViewItems.itemsSelectors.itemOrderedChildrenIds(store.state, parentId);
        if (siblings.every(checkAllDescendantsSelected)) {
          shouldRegenerateModel = true;
          newModelLookup[parentId] = true;
          selectParents(parentId);
        }
      };
      selectParents(addedItemId);
    }
  });
  changes.removed.forEach(removedItemId => {
    if (selectionPropagation.parents) {
      let parentId = _useTreeViewItems.itemsSelectors.itemParentId(store.state, removedItemId);
      while (parentId != null) {
        if (newModelLookup[parentId]) {
          shouldRegenerateModel = true;
          delete newModelLookup[parentId];
        }
        parentId = _useTreeViewItems.itemsSelectors.itemParentId(store.state, parentId);
      }
    }
    if (selectionPropagation.descendants) {
      const deSelectDescendants = itemId => {
        if (itemId !== removedItemId) {
          shouldRegenerateModel = true;
          delete newModelLookup[itemId];
        }
        _useTreeViewItems.itemsSelectors.itemOrderedChildrenIds(store.state, itemId).forEach(deSelectDescendants);
      };
      deSelectDescendants(removedItemId);
    }
  });
  return shouldRegenerateModel ? Object.keys(newModelLookup) : newModel;
};
exports.propagateSelection = propagateSelection;